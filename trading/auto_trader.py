import json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\n\nlogger = logging.getLogger(__name__)\n\n\nclass OrderType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\n\nclass OrderStatus(str, Enum):\n    PENDING = \"PENDING\"\n    EXECUTED = \"EXECUTED\"\n    CANCELLED = \"CANCELLED\"\n    CLOSED = \"CLOSED\"\n\n\n@dataclass\nclass Trade:\n    trade_id: str\n    symbol: str\n    order_type: OrderType\n    entry_price: float\n    entry_quantity: float\n    entry_time: str\n    exit_price: Optional[float] = None\n    exit_quantity: Optional[float] = None\n    exit_time: Optional[str] = None\n    status: OrderStatus = OrderStatus.PENDING\n    confidence: float = 0.0\n    profit_loss: float = 0.0\n    profit_loss_percent: float = 0.0\n    commission: float = 0.0\n\n    def to_dict(self):\n        data = asdict(self)\n        data['order_type'] = self.order_type.value\n        data['status'] = self.status.value\n        return data\n\n\nclass BitgetFeeCalculator:\n    \"\"\"Bitget普通用戶合約手續費計算器\"\"\"\n    \n    MAKER_FEE = 0.0002  # 0.02%\n    TAKER_FEE = 0.0005  # 0.05%\n    \n    @classmethod\n    def calculate_entry_fee(cls, quantity: float, price: float) -> float:\n        \"\"\"計算進場手續費\"\"\"\n        notional = quantity * price\n        return notional * cls.TAKER_FEE\n    \n    @classmethod\n    def calculate_exit_fee(cls, quantity: float, price: float) -> float:\n        \"\"\"計算出場手續費\"\"\"\n        notional = quantity * price\n        return notional * cls.TAKER_FEE\n    \n    @classmethod\n    def calculate_total_fee(cls, entry_quantity: float, entry_price: float,\n                           exit_quantity: float, exit_price: float) -> float:\n        \"\"\"計算總手續費\"\"\"\n        entry_fee = cls.calculate_entry_fee(entry_quantity, entry_price)\n        exit_fee = cls.calculate_exit_fee(exit_quantity, exit_price)\n        return entry_fee + exit_fee\n\n\nclass AutoTrader:\n    \"\"\"自動交易引擎\"\"\"\n    \n    def __init__(self, initial_balance: float = 1000.0, \n                 position_size_percent: float = 0.1,\n                 confidence_threshold: float = 0.5):\n        self.initial_balance = initial_balance\n        self.current_balance = initial_balance\n        self.position_size_percent = position_size_percent\n        self.confidence_threshold = confidence_threshold\n        self.trades: List[Trade] = []\n        self.open_positions: Dict[str, Trade] = {}\n        self.trade_counter = 0\n        \n    def set_parameters(self, initial_balance: Optional[float] = None,\n                      position_size_percent: Optional[float] = None,\n                      confidence_threshold: Optional[float] = None):\n        \"\"\"更新交易參數\"\"\"\n        if initial_balance is not None:\n            self.initial_balance = initial_balance\n            self.current_balance = initial_balance\n        if position_size_percent is not None:\n            self.position_size_percent = position_size_percent\n        if confidence_threshold is not None:\n            self.confidence_threshold = confidence_threshold\n    \n    def calculate_position_size(self, price: float) -> float:\n        \"\"\"根據可用餘額計算頭寸大小\"\"\"\n        available_balance = self.current_balance\n        capital_to_use = available_balance * self.position_size_percent\n        quantity = capital_to_use / price\n        return quantity\n    \n    def should_trade(self, confidence: float) -> bool:\n        \"\"\"判斷是否應該交易\"\"\"\n        return confidence >= self.confidence_threshold\n    \n    def execute_buy_signal(self, signal_data: Dict) -> Optional[Trade]:\n        \"\"\"執行買入信號\"\"\"\n        confidence = signal_data.get('confidence', 0.0)\n        \n        if not self.should_trade(confidence):\n            logger.info(f\"信心度 {confidence:.2%} 低於閾值 {self.confidence_threshold:.2%}，跳過交易\")\n            return None\n        \n        symbol = signal_data.get('symbol', 'UNKNOWN')\n        price = signal_data.get('price', 0.0)\n        timestamp = signal_data.get('timestamp', datetime.now().isoformat())\n        \n        if price <= 0:\n            logger.error(\"無效的價格\")\n            return None\n        \n        quantity = self.calculate_position_size(price)\n        if quantity <= 0:\n            logger.error(\"無效的頭寸大小\")\n            return None\n        \n        entry_fee = BitgetFeeCalculator.calculate_entry_fee(quantity, price)\n        \n        self.trade_counter += 1\n        trade = Trade(\n            trade_id=f\"TRADE_{self.trade_counter}\",\n            symbol=symbol,\n            order_type=OrderType.BUY,\n            entry_price=price,\n            entry_quantity=quantity,\n            entry_time=timestamp,\n            status=OrderStatus.EXECUTED,\n            confidence=confidence,\n            commission=entry_fee\n        )\n        \n        self.current_balance -= (quantity * price + entry_fee)\n        self.open_positions[symbol] = trade\n        self.trades.append(trade)\n        \n        logger.info(f\"BUY 信號已執行: {symbol} 數量={quantity:.4f} 價格=${price:.2f} 手續費=${entry_fee:.4f}\")\n        return trade\n    \n    def execute_sell_signal(self, signal_data: Dict) -> Optional[Trade]:\n        \"\"\"執行賣出信號\"\"\"\n        confidence = signal_data.get('confidence', 0.0)\n        \n        if not self.should_trade(confidence):\n            logger.info(f\"信心度 {confidence:.2%} 低於閾值 {self.confidence_threshold:.2%}，跳過交易\")\n            return None\n        \n        symbol = signal_data.get('symbol', 'UNKNOWN')\n        price = signal_data.get('price', 0.0)\n        timestamp = signal_data.get('timestamp', datetime.now().isoformat())\n        \n        if symbol not in self.open_positions:\n            logger.warning(f\"沒有 {symbol} 的開倉頭寸\")\n            return None\n        \n        open_trade = self.open_positions[symbol]\n        exit_fee = BitgetFeeCalculator.calculate_exit_fee(\n            open_trade.entry_quantity, price\n        )\n        \n        gross_proceeds = open_trade.entry_quantity * price\n        total_fee = open_trade.commission + exit_fee\n        net_proceeds = gross_proceeds - exit_fee\n        \n        profit_loss = net_proceeds - (open_trade.entry_quantity * open_trade.entry_price + open_trade.commission)\n        profit_loss_percent = profit_loss / (open_trade.entry_quantity * open_trade.entry_price + open_trade.commission)\n        \n        open_trade.exit_price = price\n        open_trade.exit_quantity = open_trade.entry_quantity\n        open_trade.exit_time = timestamp\n        open_trade.status = OrderStatus.CLOSED\n        open_trade.profit_loss = profit_loss\n        open_trade.profit_loss_percent = profit_loss_percent\n        open_trade.commission += exit_fee\n        \n        self.current_balance += net_proceeds\n        del self.open_positions[symbol]\n        \n        logger.info(f\"SELL 信號已執行: {symbol} 價格=${price:.2f} 獲利/虧損=${profit_loss:.4f} ({profit_loss_percent:.2%}) 手續費=${total_fee:.4f}\")\n        return open_trade\n    \n    def process_signal(self, signal_data: Dict) -> Optional[Trade]:\n        \"\"\"處理信號\"\"\"\n        signal_type = signal_data.get('signal_type', '').upper()\n        \n        if signal_type == 'BUY':\n            return self.execute_buy_signal(signal_data)\n        elif signal_type == 'SELL':\n            return self.execute_sell_signal(signal_data)\n        else:\n            logger.warning(f\"未知的信號類型: {signal_type}\")\n            return None\n    \n    def get_account_summary(self) -> Dict:\n        \"\"\"獲取帳戶摘要\"\"\"\n        closed_trades = [t for t in self.trades if t.status == OrderStatus.CLOSED]\n        open_trades = list(self.open_positions.values())\n        \n        total_profit_loss = sum(t.profit_loss for t in closed_trades)\n        winning_trades = len([t for t in closed_trades if t.profit_loss > 0])\n        losing_trades = len([t for t in closed_trades if t.profit_loss < 0])\n        win_rate = winning_trades / len(closed_trades) if closed_trades else 0\n        \n        return {\n            'total_balance': self.current_balance,\n            'initial_balance': self.initial_balance,\n            'available_balance': self.current_balance,\n            'total_trades': len(self.trades),\n            'closed_trades': len(closed_trades),\n            'open_trades': len(open_trades),\n            'total_profit_loss': total_profit_loss,\n            'winning_trades': winning_trades,\n            'losing_trades': losing_trades,\n            'win_rate': win_rate,\n            'open_positions': [t.to_dict() for t in open_trades]\n        }\n    \n    def export_trades(self) -> List[Dict]:\n        \"\"\"匯出交易記錄\"\"\"\n        return [t.to_dict() for t in self.trades]\n    \n    def reset(self, initial_balance: Optional[float] = None):\n        \"\"\"重置交易\"\"\"\n        if initial_balance is not None:\n            self.initial_balance = initial_balance\n        self.current_balance = self.initial_balance\n        self.trades.clear()\n        self.open_positions.clear()\n        self.trade_counter = 0\n        logger.info(\"交易引擎已重置\")\n"